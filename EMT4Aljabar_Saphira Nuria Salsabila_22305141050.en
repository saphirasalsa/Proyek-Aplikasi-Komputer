% * EMT untuk Perhitungan Aljabar
% 
% Pada notebook ini Anda belajar menggunakan EMT untuk melakukan
% berbagai perhitungan terkait dengan materi atau topik dalam Aljabar.
% Kegiatan yang harus Anda lakukan adalah sebagai berikut:
% 
% - Membaca secara cermat dan teliti notebook ini;
%% - Menerjemahkan teks bahasa Inggris ke bahasa Indonesia;
%% - Mencoba contoh-contoh perhitungan (perintah EMT) dengan cara
% meng-ENTER setiap perintah EMT yang ada (pindahkan kursor ke baris
% perintah)
%% - Jika perlu Anda dapat memodifikasi perintah yang ada dan memberikan
% keterangan/penjelasan tambahan terkait hasilnya.
%% - Menyisipkan baris-baris perintah baru untuk mengerjakan soal-soal
% Aljabar dari file PDF yang saya berikan;
%% - Memberi catatan hasilnya.
%% - Jika perlu tuliskan soalnya pada teks notebook (menggunakan format
% LaTeX).
%% - Gunakan tampilan hasil semua perhitungan yang eksak atau simbolik
% dengan format LaTeX. (Seperti contoh-contoh pada notebook ini.)
% 
% ** Contoh pertama
% 
% Menyederhanakan bentuk aljabar:
% 
% latex: 6x^{-3}y^5\times -7x^2y^{-9}
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-001.png
% // latex: 6x^{-3}y^5\times -7x^2y^{-9}
% 
>$&6*x^(-3)*y^5*-7*x^2*y^(-9)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-002.png
% // latex: -\frac{42}{x\,y^4}
% 
% Menjabarkan:
% 
% latex: (6x^{-3}+y^5)(-7x^2-y^{-9})
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-003.png
% // latex: (6x^{-3}+y^5)(-7x^2-y^{-9})
>$&showev('expand((6*x^(-3)+y^5)*(-7*x^2-y^(-9))))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-004.png
% // latex: {\it expand}\left(\left(-\frac{1}{y^9}-7\,x^2\right)\,\left(y^5+  \frac{6}{x^3}\right)\right)=-7\,x^2\,y^5-\frac{1}{y^4}-\frac{6}{x^3  \,y^9}-\frac{42}{x}
% 
% ** Baris Perintah
% 
% Baris perintah Euler terdiri dari satu atau beberapa perintah Euler
% diikuti dengan titik koma ";" atau koma ",". Titik koma mencegah
% pencetakan hasilnya. Koma setelah perintah terakhir dapat dihilangkan.
% 
% Baris perintah berikut hanya akan mencetak hasil ekspresi, bukan tugas
% atau perintah format.
>r:=2; h:=4; pi*r^2*h/3
16.7551608191
% Perintah harus dipisahkan dengan yang kosong. Baris perintah berikut
% mencetak kedua hasilnya.
>pi*2*r*h, %+2*pi*r*h // Ingat tanda % menyatakan hasil perhitungan terakhir sebelumnya
50.2654824574
100.530964915
% Baris perintah dijalankan sesuai urutan yang ditekan pengguna kembali.
% Jadi, Anda mendapatkan nilai baru setiap kali Anda menjalankan baris
% kedua.
>x := 1;
>x := cos(x) // nilai cosinus (x dalam radian)
0.540302305868
>x := cos(x)
0.857553215846
% Jika dua jalur dihubungkan dengan "..." kedua jalur akan selalu
% dijalankan secara bersamaan.
>x := 1.5; ...
>x := (x+2/x)/2, x := (x+2/x)/2, x := (x+2/x)/2, 
1.41666666667
1.41421568627
1.41421356237
% Ini juga merupakan cara yang baik untuk menyebarkan perintah panjang
% ke dua baris atau lebih. Anda dapat menekan Ctrl+Return untuk
%% membagi baris menjadi dua pada posisi kursor saat ini, atau Ctlr+Back
% untuk menggabungkan baris.
% 
% Untuk melipat semua multi-garis tekan Ctrl+L. Maka garis-garis
% berikutnya hanya akan terlihat, jika salah satunya mendapat fokus.
% Untuk melipat satu multi-baris, mulailah baris pertama dengan "%+".
>%+ x=4+5; ...
> // This line will not be visible once the cursor is off the line
% Baris yang dimulai dengan %% tidak akan terlihat sama sekali.
>%% x^2 // This line will be invisible.
81
% Euler mendukung loop di baris perintah, asalkan cocok ke dalam satu
% baris atau multi-baris. Tentu saja, pembatasan ini tidak berlaku dalam
%% program. Untuk informasi lebih lanjut lihat pendahuluan berikut.
% 
>x=1; for i=1 to 5; x := (x+2/x)/2, end; // menghitung akar 2
1.5
1.41666666667
1.41421568627
1.41421356237
1.41421356237
% Tidak apa-apa menggunakan multi-baris. Pastikan baris diakhiri dengan
% "...".
% 
>x := 1.5; // comments go here before the ...
>repeat xnew:=(x+2/x)/2; until xnew~=x; ...
>   x := xnew; ...
>end; ...
>x,
1.41421356237
% Struktur bersyarat juga berfungsi.
>if E^pi>pi^E; then "Thought so!", endif;
Thought so!
% Saat Anda menjalankan perintah, kursor dapat berada di posisi mana pun
% di baris perintah. Anda dapat kembali ke perintah sebelumnya
%% atau melompat ke perintah berikutnya dengan tombol panah. Atau Anda
% dapat mengklik bagian komentar di atas perintah untuk membuka
% perintah.
% 
% Saat Anda menggerakkan kursor di sepanjang garis, pasangan tanda
% kurung atau tanda kurung buka dan tutup akan disorot. Juga, perhatikan
% baris status. Setelah tanda kurung buka dari fungsi sqrt(), baris
% status akan menampilkan teks bantuan untuk fungsi tersebut.
%% Jalankan perintah dengan kunci kembali.
>sqrt(sin(10°)/cos(20°))
0.429875017772
% Untuk melihat bantuan untuk perintah terbaru, buka jendela bantuan
% dengan F1. Di sana, Anda dapat memasukkan teks untuk
%% dicari. Pada baris kosong, bantuan untuk jendela bantuan akan
% ditampilkan. Anda dapat menekan escape untuk menghapus garis,
%% atau untuk menutup jendela bantuan.
% 
% Anda dapat mengklik dua kali pada perintah apa pun untuk membuka
% bantuan untuk perintah ini. Coba klik dua kali pada exp command di
% bawah pada baris perintah.
>exp(log(2.5))
2.5
% Anda juga dapat menyalin dan menempel di Euler. Gunakan Ctrl-C dan
% Ctrl-V untuk ini. Untuk menandai teks, seret mouse atau gunakan shift
%% bersamaan dengan tombol kursor apa pun. Selain itu, Anda dapat
% menyalin tanda kurung yang disorot.
>
% 
% ** Sintaks Dasar
% 
% Euler mengetahui fungsi matematika biasa. Seperti yang Anda lihat di
% atas, fungsi trigonometri bekerja dalam radian atau derajat. Untuk
%% mengonversi ke derajat, tambahkan simbol derajat (dengan tombol F7) ke
% nilainya, atau gunakan fungsi rad(x). Fungsi akar kuadrat disebut
%% sqrt di Euler. Tentu saja, x^(1/2) juga dimungkinkan.
% 
% Untuk menyetel variabel, gunakan "=" atau ":=". Demi kejelasan,
% pendahuluan ini menggunakan bentuk yang terakhir. Spasi tidak penting.
%% Tapi jarak antar perintah diharapkan.
% 
% Beberapa perintah dalam satu baris dipisahkan dengan "," atau ";".
% Titik koma menekan keluaran perintah. Di akhir baris perintah, ","
%% diasumsikan, jika ";" hilang.
>g:=9.81; t:=2.5; 1/2*g*t^2
30.65625
% EMT uses a programming syntax for expressions. To enter
% 
% latex: e^2 \cdot \left( \frac{1}{3+4 \log(0.6)}+\frac{1}{7} \right)
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-005.png
% // latex: e^2 \cdot \left( \frac{1}{3+4 \log(0.6)}+\frac{1}{7} \right)
% 
% you have to set the correct brackets and use / for fractions. Watch
% the highlighted brackets for assistance. Note that the Euler constant
% e is named E in EMT.
>E^2*(1/(3+4*log(0.6))+1/7)
8.77908249441
% To compute a complicate expression like
% 
% latex: \left(\frac{\frac17 + \frac18 + 2}{\frac13 + \frac12}\right)^2 \pi
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-006.png
% // latex: \left(\frac{\frac17 + \frac18 + 2}{\frac13 + \frac12}\right)^2 \pi
% 
% you need to enter it in line form.
>((1/7 + 1/8 + 2) / (1/3 + 1/2))^2 * pi
23.2671801626
% Carefully put brackets around sub-expressions that need to be computed first. 
% EMT assists you by highlighting the expression that the closing bracket finishes. 
% You will also have to enter the name "pi" for the Greek letter pi.
% 
% The result of this computation is a floating point number. It is by
% default printed with about 12 digits accuracy.
% In the following command line, we also learn how we can refer to the previous
% result within the same line.
>1/3+1/7, fraction %
0.47619047619
10/21
% 
% An Euler command can be an expression or a primitive command. An expression
% is made of operators and functions. If necessary, it must contain brackets to
% force the correct order of execution. In doubt, setting a bracket is a good
% idea. Note that EMT shows opening and closing brackets while editing the
% command line.
>(cos(pi/4)+1)^3*(sin(pi/4)+1)^2
14.4978445072
% The numerical operators of Euler include
% 
%  + unary or operator plus
%%  - unary or operator minus
%%  *, /
%%  . the matrix product
%%  a^b power for positive a or integer b (a**b works too)
%%  n! the factorial operator
% 
% and many more.
% 
% Here are some of the functions you might need. There are many more.
% 
%  sin,cos,tan,atan,asin,acos,rad,deg
%%  log,exp,log10,sqrt,logbase
%%  bin,logbin,logfac,mod,floor,ceil,round,abs,sign
%%  conj,re,im,arg,conj,real,complex
%%  beta,betai,gamma,complexgamma,ellrf,ellf,ellrd,elle
%%  bitand,bitor,bitxor,bitnot
% 
% Some commands have aliases, e.g. ln for log.
>ln(E^2), arctan(tan(0.5))
2
0.5
>sin(30°)
0.5
% Make sure to use parentheses (round brackets), whenever there is doubt about
% the order of execution! The following is not the same as (2^3)^4, which is
% the default for 2^3^4 in EMT (some numerical systems do it the other way).
>2^3^4, (2^3)^4, 2^(3^4)
2.41785163923e+24
4096
2.41785163923e+24
% ** Real Numbers
% 
% The primary data type in Euler is the real number. Reals are
% represented in IEEE format with about 16 decimal digits of accuracy.
>longest 1/3
     0.3333333333333333 
% The internal dual representation takes 8 bytes.
>printdual(1/3)
1.0101010101010101010101010101010101010101010101010101*2^-2
>printhex(1/3)
5.5555555555554*16^-1
% ** Strings
% 
% A string in Euler is defined with "...".
>"A string can contain anything."
A string can contain anything.
% Strings can be concatenated with | or with +. This also works with numbers,
% which are converted to strings in that case.
>"The area of the circle with radius " + 2 + " cm is " + pi*4 + " cm^2."
The area of the circle with radius 2 cm is 12.5663706144 cm^2.
% The print function does also convert a number to a string. It can take a
% number of digits and a number of places (0 for dense output), and optimally a
% unit.
>"Golden Ratio : " + print((1+sqrt(5))/2,5,0)
Golden Ratio : 1.61803
% There is a special string none, which does not print. It is returned by some
% functions, when the result does not matter. (It is returned automatically, if
% the function does not have a return statement.)
>none
% To convert a string to a number simply evaluate it. This works for
% expressions too (see below).
>"1234.5"()
1234.5
% To define a string vector, use the vector [...] notation.
>v:=["affe","charlie","bravo"]
affe
charlie
bravo
% The empty string vector is denoted by [none]. String vectors can be
% concatenated.
>w:=[none]; w|v|v
affe
charlie
bravo
affe
charlie
bravo
% Strings can contain Unicode characters. Internally, these strings contain
% UTF-8 code. To generate such a string, use u"..." and one of the HTML
% entities.
% 
% Unicode strings can be concatenated like other strings.
>u"&alpha; = " + 45 + u"&deg;" // pdfLaTeX mungkin gagal menampilkan secara benar
ï»¿Î± = 45Â°
% I
>
% In comments, the same entities like &alpha;, &beta; etc. can be used. This may be
% a quick alternative to Latex. (More details on comments below).
>//
% There are some functions to create or analyze unicode strings. The function
% strtochar() will recognize Unicode strings, and translate them correctly.
>v=strtochar(u"&Auml; is a German letter")
[196,  32,  105,  115,  32,  97,  32,  71,  101,  114,  109,  97,  110,
32,  108,  101,  116,  116,  101,  114]
% The result is a vector of Unicode numbers. The converse function is
% chartoutf().
>v[1]=strtochar(u"&Uuml;")[1]; chartoutf(v)
ï»¿Ãœ is a German letter
% The function utf() can translate a string with entities in a variable into a
% Unicode string.
>s="We have &alpha;=&beta;."; utf(s) // pdfLaTeX mungkin gagal menampilkan secara benar
ï»¿We have Î±=Î².
% It is also possible to use numerical entities.
>u"&#196;hnliches"
ï»¿Ã„hnliches
% ** Boolean Values
% 
% Boolean values are represented with 1=true or 0=false in Euler.
% Strings can be compared, just like numbers.
>2<1, "apel"<"banana"
0
1
% "and" is the operator "&&" and "or" is the operator "||", as in the C
% language. (The words "and" and "or" can only be used in conditions for "if".)
>2<E && E<3
1
% Boolean operators obey the rules of the matrix language.
>(1:10)>5, nonzeros(%)
[0,  0,  0,  0,  0,  1,  1,  1,  1,  1]
[6,  7,  8,  9,  10]
% You can use the function nonzeros() to extract specific elements form a
% vector. In the example, we use the conditional isprime(n).
>N=2|3:2:99 // N berisi elemen 2 dan bilangan2 ganjil dari 3 s.d. 99
[2,  3,  5,  7,  9,  11,  13,  15,  17,  19,  21,  23,  25,  27,  29,
31,  33,  35,  37,  39,  41,  43,  45,  47,  49,  51,  53,  55,  57,
59,  61,  63,  65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,
87,  89,  91,  93,  95,  97,  99]
>N[nonzeros(isprime(N))] //pilih anggota2 N yang prima
[2,  3,  5,  7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43,  47,
53,  59,  61,  67,  71,  73,  79,  83,  89,  97]
% ** Output Formats
% 
% The default output format of EMT prints 12 digits. To make sure that
% we see the default, we reset the format.
>defformat; pi
3.14159265359
% Internally, EMT uses the IEEE standard for double numbers with about 16
% decimal digits. To see the full number of digits, use the command
% "longestformat", or we use the operator "longest" to display the result in
% the longest format.
>longest pi
      3.141592653589793 
% Here is the internal hexadecimal representation of a double number.
>printhex(pi)
3.243F6A8885A30*16^0
% The output format can be changed permanently with a format command.
>format(12,5); 1/3, pi, sin(1)
    0.33333 
    3.14159 
    0.84147 
% The default is format(12).
>format(12); 1/3
0.333333333333
% Functions like "shortestformat", "shortformat", "longformat" work for vectors
% in the following way.
>shortestformat; random(3,8)
  0.66    0.2   0.89   0.28   0.53   0.31   0.44    0.3 
  0.28   0.88   0.27    0.7   0.22   0.45   0.31   0.91 
  0.19   0.46  0.095    0.6   0.43   0.73   0.47   0.32 
% The default format for scalars is format(12). But this can be changed.
>setscalarformat(5); pi
3.1416
% The function "longestformat" set the scalar format too.
>longestformat; pi
3.141592653589793
% For reference, here is a list of the most important output formats.
% 
%  shortestformat shortformat longformat, longestformat
%%  format(length,digits) goodformat(length)
%%  fracformat(length)
%%  defformat
% 
% The internal accuracy of EMT is about 16 decimal places, which is the IEEE
% standard. Numbers are stored in this internal format.
% 
% But the output format of EMT can be set in a flexible way.
>longestformat; pi,
3.141592653589793
>format(10,5); pi
  3.14159 
% The default is defformat().
>defformat; // default
% There are short operators which print only one value. The operator "longest"
% will print all valid digits of a number.
>longest pi^2/2
      4.934802200544679 
% There is also a short operator for printing a result in fractional format. We
% have already used it above.
>fraction 1+1/2+1/3+1/4
25/12
% Since the internal format uses a binary way to store numbers, the value 0.1
% will not be represented exactly. The error adds up a bit, as you see in the
% following computation.
>longest 0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1-1
 -1.110223024625157e-16 
% But with the default "longformat" you will not notice this. For convenience,
% the output of very small numbers is 0.
>0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1-1
0
% * Expressions
% 
% Strings or names can be used to store mathematical expressions, which can be evaluated
% by EMT. For this, use parentheses after the expression. If you intend to use a string
% as an expression, use the convention to name it "fx" or "fxy" etc. Expressions take
% precedence over functions.
% 
% Global variables can be used in the evaluation.
>r:=2; fx:="pi*r^2"; longest fx()
      12.56637061435917 
% Parameters are assigned to x, y, and z in that order. Additional parameters
% can be added using assigned parameters.
>fx:="a*sin(x)^2"; fx(5,a=-1)
-0.919535764538
% Note that expression will always use global variables, even if there is a
% variable in a function with the same name. (Otherwise the evaluation of
% expressions in functions could have very confusing results for the user that
% called the function.)
>at:=4; function f(expr,x,at) := expr(x); ...
>f("at*x^2",3,5) // computes 4*3^2 not 5*3^2
36
% If you want to use another value for "at" than the global value you need to
% add "at=value".
>at:=4; function f(expr,x,a) := expr(x,at=a); ...
>f("at*x^2",3,5)
45
% For reference, we remark that call collections (discussed elsewhere) can
% contain expressions. So we can make the above example as follows.
>at:=4; function f(expr,x) := expr(x); ...
>f({{"at*x^2",at=5}},3)
45
% Expressions in x are often used just like functions.
%% Note that defining a function with the same name like a global symbolic
% expression deletes this variable to avoid confusion between symbolic
% expressions and functions.
>f &= 5*x;
>function f(x) := 6*x;
>f(2)
12
% By way of convention, symbolic or numerical expressions should be named fx,
% fxy etc. This naming scheme should not be used for functions.
>fx &= diff(x^x,x); $&fx
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-007.png
% // latex: x^{x}\,\left(\log x+1\right)
% A special form of an expression allows any variable as an unnamed parameter
% to the evaluation of the expression, not just "x", "y" etc. For this, start
% the expression with "@(variables) ...".
>"@(a,b) a^2+b^2", %(4,5)
@(a,b) a^2+b^2
41
% This allows to manipulate expressions in other variables for functions of EMT
% which need an expression in "x".
% 
% The most elementary way to define a simple function is to store its formula
% in a symbolic or numerical expression. If the main variable is x, the
% expression can be evaluated just like a function.
% 
% As you see in the following example, global variables are visible during the
% evaluation.
>fx &= x^3-a*x;  ...
>a=1.2; fx(0.5)
-0.475
% All other variables in the expression can be specified in the evaluation
% using an assigned parameter.
>fx(0.5,a=1.1)
-0.425
% An expression needs not be symbolic. This is necessary, if the expression
% contains functions, which are only known in the numerical kernel, not in
% Maxima.
% 
% * Symbolic Mathematics
% 
% EMT does symbolic math with the help of Maxima. For details, start with the
% following tutorial, or browse the reference for Maxima. Experts in Maxima
% should note that there are differences in the syntax between the original
% syntax of Maxima and the default syntax of symbolic expressions in EMT.
% 
% Symbolic math is integrated seamlessly into Euler with &. Any expression
% starting with & is a symbolic expression. It is evaluated and printed by
% Maxima.
% 
% First of all, Maxima has an "infinite" arithmetic which can handle
% very large numbers.
>$&44!
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-008.png
% // latex: 2658271574788448768043625811014615890319638528000000000
% This way, you can compute large results exactly. Let us compute
% 
% latex: C(44,10) = \frac{44!}{34! \cdot 10!}
>$& 44!/(34!*10!) // nilai C(44,10)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-009.png
% // latex: 2481256778
% Of course, Maxima has a more efficient function for this (as does the
% numerical part of EMT).
>$binomial(44,10) //menghitung C(44,10) menggunakan fungsi binomial()
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-010.png
% // latex: 2481256778
% To learn more about a specific function double click on it. E.g., try
% double clicking on "&binomial" in the previous command line. This
% opens the documentation of Maxima as provided by the authors of that
% program.
% 
% You will learn that the following works too.
% 
% latex: C(x,3)=\frac{x!}{(x-3)!3!}=\frac{(x-2)(x-1)x}{6}
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-011.png
% // latex: C(x,3)=\frac{x!}{(x-3)!3!}=\frac{(x-2)(x-1)x}{6}
>$binomial(x,3) // C(x,3)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-012.png
% // latex: \frac{\left(x-2\right)\,\left(x-1\right)\,x}{6}
% If you want to replace x with any specific value use "with".
>$&binomial(x,3) with x=10 // substitusi x=10 ke C(x,3)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-013.png
% // latex: 120
% That way you can use a solution of an equation in another equation.
% 
% Symbolic expressions are printed by Maxima in 2D form. The reason for this is a special
% symbolic flag in the string.
% 
% As you will have seen in previous and following examples, if you have LaTeX installed,
% you can print a symbolic expression with Latex. If not, the following command will
% issue an error message.
% 
% To print a symbolic expression with LaTeX, use $ infront of & (or you may ommit &)
% before the command. Do not run the Maxima commands with $, if you don't have LaTeX
% installed.
>$(3+x)/(x^2+1)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-014.png
% // latex: \frac{x+3}{x^2+1}
% Symbolic expressions are parsed by Euler. If you need a complex syntax in one
% expression, you can enclose the expression in "...". To use more than a
% simple expression is possible, but strongly discouraged.
>&"v := 5; v^2"

                                  25

% For completeness, we remark that symbolic expressions can be used in
% programs, but need to be enclosed in quotes. Moreover, it is much more
% effective to call Maxima at compile time if possible.
>$&expand((1+x)^4), $&factor(diff(%,x)) // diff: turunan, factor: faktor
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-015.png
% // latex: x^4+4\,x^3+6\,x^2+4\,x+1
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-016.png
% // latex: 4\,\left(x+1\right)^3
% Again, % refers to the previous result.
% 
% To make things easier we save the solution to a symbolic variable.
% Symbolic variables are defined with "&=".
>fx &= (x+1)/(x^4+1); $&fx
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-017.png
% // latex: \frac{x+1}{x^4+1}
% Symbolic expressions can be used in other symbolic expressions.
>$&factor(diff(fx,x))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-018.png
% // latex: \frac{-3\,x^4-4\,x^3+1}{\left(x^4+1\right)^2}
% A direct input of Maxima commands is available too. Start the command line
% with "::". The syntax of Maxima is adapted to the syntax of EMT (called the
% "compatibility mode").
>&factor(20!)

                         2432902008176640000

>::: factor(10!)

                               8  4  2
                              2  3  5  7

>:: factor(20!)

                        18  8  4  2
                       2   3  5  7  11 13 17 19

% If you are an expert in Maxima, you may wish to use the original syntax of
% Maxima. You can do this with ":::".
>::: av:g$ av^2;

                                   2
                                  g

>fx &= x^3*exp(x), $fx

                                 3  x
                                x  E

 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-019.png
% // latex: x^3\,e^{x}
% Such variables can be used in other symbolic expressions. Note, that in the
% following command the right hand side of &= is evaluated before the
% assignment to Fx.
>&(fx with x=5), $%, &float(%)

                                     5
                                125 E

 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-020.png
% // latex: 125\,e^5

                          18551.64488782208

>fx(5)
18551.6448878
>
% For the evaluation of an expression with specific values of the variables,
% you can use the "with" operator.
% 
% The following command line also demonstrates that Maxima can evaluate an
% expression numerically with float().
>&(fx with x=10)-(fx with x=5), &float(%)

                                10        5
                          1000 E   - 125 E


                         2.20079141499189e+7

>$factor(diff(fx,x,2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-021.png
% // latex: x\,\left(x^2+6\,x+6\right)\,e^{x}
% To get the Latex code for an expression, you can use the tex command.
>tex(fx)
x^3\,e^{x}
% Symbolic expressions can be evaluated just like numerical expressions.
>fx(0.5)
0.206090158838
% In symbolic expressions, this does not work, since Maxima does not support
% it. Instead, use the "with" syntax (a nicer form of the at(...) command of
% Maxima).
>$&fx with x=1/2
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-022.png
% // latex: \frac{\sqrt{e}}{8}
% The assignment can also be symbolic.
>$&fx with x=1+t
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-023.png
% // latex: \left(t+1\right)^3\,e^{t+1}
>
% The command solve solves symbolic expressions for a variable in Maxima. The
% result is a vector of solutions.
>$&solve(x^2+x=4,x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-024.png
% // latex: \left[ x=\frac{-\sqrt{17}-1}{2} , x=\frac{\sqrt{17}-1}{2} \right] 
% Compare with the numerical "solve" command in Euler, which needs a start
% value, and optionally a target value.
>solve("x^2+x",1,y=4)
1.56155281281
% The numerical values of the symbolic solution can be computed by evaluation
% of the symbolic result. Euler will read over the assignments x= etc. If you
% do not need the numerical results for further computations you can also let
% Maxima find the numerical values.
>sol &= solve(x^2+2*x=4,x); $&sol, sol(), $&float(sol)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-025.png
% // latex: \left[ x=-\sqrt{5}-1 , x=\sqrt{5}-1 \right] 
[-3.23607,  1.23607]
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-026.png
% // latex: \left[ x=-3.23606797749979 , x=1.23606797749979 \right] 
% To get a specific symbolic solution, one can use "with" and an index.
>$&solve(x^2+x=1,x), x2 &= x with %[2]; $&x2
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-027.png
% // latex: \left[ x=\frac{-\sqrt{5}-1}{2} , x=\frac{\sqrt{5}-1}{2} \right] 
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-028.png
% // latex: \frac{\sqrt{5}-1}{2}
% To solve a system of equations, use a vector of equations. The result is a
% vector of solutions.
>sol &= solve([x+y=3,x^2+y^2=5],[x,y]); $&sol, $&x*y with sol[1]
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-029.png
% // latex: \left[ \left[ x=2 , y=1 \right]  , \left[ x=1 , y=2 \right]    \right] 
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-030.png
% // latex: 2
% Symbolic expressions can have flags, which indicate a special treatment in
% Maxima. Some flags can be used as commands too, others can't. Flags are
% appended with "|" (a nicer form of "ev(...,flags)")
>$& diff((x^3-1)/(x+1),x) //turunan bentuk pecahan
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-031.png
% // latex: \frac{3\,x^2}{x+1}-\frac{x^3-1}{\left(x+1\right)^2}
>$& diff((x^3-1)/(x+1),x) | ratsimp //menyederhanakan pecahan
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-032.png
% // latex: \frac{2\,x^3+3\,x^2+1}{x^2+2\,x+1}
>$&factor(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-033.png
% // latex: \frac{2\,x^3+3\,x^2+1}{\left(x+1\right)^2}
% * Functions
% 
% In EMT, functions are programs defined with the command "function". It can be a
% one-line function or multiline function.
%% A one-line function can be numerical or symbolic. A numerical one-line function is
% defined by ":=".
>function f(x) := x*sqrt(x^2+1)
% For an overview, we show all possible definitions for one-line functions. A
% function can be evaluated just like any built-in Euler function.
>f(2)
4.472135955
% This function will work for vectors too, obeying the matrix language of
% Euler, since the expressions used in the function are vectorized.
>f(0:0.1:1)
[0,  0.100499,  0.203961,  0.313209,  0.430813,  0.559017,  0.699714,
0.854459,  1.0245,  1.21083,  1.41421]
% Functions can be plotted. Instead of expressions, we need only provide the
% function name.
% 
% In contrast to symbolic or numerical expressions, the function name must be
% provided in a string.
>solve("f",1,y=1)
0.786151377757
% By default, if you need to overwrite a built-in function, you must add the
% keyword "overwrite". Overwriting built-in functions is dangerous and can
% cause problems for other functions depending on them.
% 
% You can still call the built-in function as "_...", if it is function in the
% Euler core.
>function overwrite sin (x) := _sin(x°) // redine sine in degrees
>sin(45)
0.707106781187
% We better remove this redefinition of sin.
>forget sin; sin(pi/4)
0.707106781187
% ** Default Parameters
% 
% Numerical function can have default parameters.
>function f(x,a=1) := a*x^2
% Omitting this parameter uses the default value.
>f(4)
16
% Setting it overwrites the default value.
>f(4,5)
80
% An assigned parameter overwrite it too. This is used by many Euler functions
% like plot2d, plot3d.
>f(4,a=1)
16
% If a variable is not a parameter, it must be global. One-line functions can
% see global variables.
>function f(x) := a*x^2
>a=6; f(2)
24
% But an assigned parameter overrides the global value.
% 
% If the argument is not in the list of pre-defined parameters, it must be
% declared with ":="!
>f(2,a:=5)
20
% Symbolic functions are defined with "&=". They are defined in Euler and
% Maxima, and work in both worlds. The defining expression is run through
% Maxima before the definition.
>function g(x) &= x^3-x*exp(-x); $&g(x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-034.png
% // latex: x^3-x\,e^ {- x }
% Symbolic functions can be used in symbolic expressions.
>$&diff(g(x),x), $&% with x=4/3
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-035.png
% // latex: x\,e^ {- x }-e^ {- x }+3\,x^2
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-036.png
% // latex: \frac{e^ {- \frac{4}{3} }}{3}+\frac{16}{3}
% They can also be used in numerical expressions. Of course, this will only
% work if EMT can interpret everything inside the function.
>g(5+g(1))
178.635099908
% They can be used to define other symbolic functions or expressions.
>function G(x) &= factor(integrate(g(x),x)); $&G(c) // integrate: mengintegralkan
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-037.png
% // latex: \frac{e^ {- c }\,\left(c^4\,e^{c}+4\,c+4\right)}{4}
>
>solve(&g(x),0.5)
0.703467422498
% The following works too, since Euler uses the symbolic expression in the
% function g, if it does not find a symbolic variable g, and if there is a
% symbolic function g.
>solve(&g,0.5)
0.703467422498
>function P(x,n) &= (2*x-1)^n; $&P(x,n)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-038.png
% // latex: \left(2\,x-1\right)^{n}
>function Q(x,n) &= (x+2)^n; $&Q(x,n)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-039.png
% // latex: \left(x+2\right)^{n}
>$&P(x,4), $&expand(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-040.png
% // latex: \left(2\,x-1\right)^4
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-041.png
% // latex: 16\,x^4-32\,x^3+24\,x^2-8\,x+1
>P(3,4)
625
>$&P(x,4)+ Q(x,3), $&expand(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-042.png
% // latex: \left(2\,x-1\right)^4+\left(x+2\right)^3
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-043.png
% // latex: 16\,x^4-31\,x^3+30\,x^2+4\,x+9
>$&P(x,4)-Q(x,3), $&expand(%), $&factor(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-044.png
% // latex: \left(2\,x-1\right)^4-\left(x+2\right)^3
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-045.png
% // latex: 16\,x^4-33\,x^3+18\,x^2-20\,x-7
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-046.png
% // latex: 16\,x^4-33\,x^3+18\,x^2-20\,x-7
>$&P(x,4)*Q(x,3), $&expand(%), $&factor(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-047.png
% // latex: \left(x+2\right)^3\,\left(2\,x-1\right)^4
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-048.png
% // latex: 16\,x^7+64\,x^6+24\,x^5-120\,x^4-15\,x^3+102\,x^2-52\,x+8
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-049.png
% // latex: \left(x+2\right)^3\,\left(2\,x-1\right)^4
>$&P(x,4)/Q(x,1), $&expand(%), $&factor(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-050.png
% // latex: \frac{\left(2\,x-1\right)^4}{x+2}
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-051.png
% // latex: \frac{16\,x^4}{x+2}-\frac{32\,x^3}{x+2}+\frac{24\,x^2}{x+2}-\frac{8  \,x}{x+2}+\frac{1}{x+2}
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-052.png
% // latex: \frac{\left(2\,x-1\right)^4}{x+2}
>function f(x) &= x^3-x; $&f(x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-053.png
% // latex: x^3-x
% With &= the function is symbolic, and can be used in other symbolic
% expressions.
>$&integrate(f(x),x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-054.png
% // latex: \frac{x^4}{4}-\frac{x^2}{2}
% With := the function is numerical. A good example is a definite
% integral like
% 
% latex: f(x) = \int_1^x t^t \, dt,
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-055.png
% // latex: f(x) = \int_1^x t^t \, dt,
% 
% which can not be evaluated symbolically.
% 
% If we redefine the function with the keyword "map" it can be used for
% vectors x. Internally, the function is called for all values of x
% once, and the results are stored in a vector.
>function map f(x) := integrate("x^x",1,x)
>f(0:0.5:2)
[-0.783431,  -0.410816,  0,  0.676863,  2.05045]
% Functions can have default values for parameters.
>function mylog (x,base=10) := ln(x)/ln(base);
% Now the function can be called with or without a parameter "base".
>mylog(100), mylog(2^6.7,2)
2
6.7
% Moreover, it is possible to use assigned parameters.
>mylog(E^2,base=E)
2
% 
% Often, we want to use functions for vectors at one place, and for individual
% elements at other places. This is possible with vector parameters.
>function f([a,b]) &= a^2+b^2-a*b+b; $&f(a,b), $&f(x,y)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-056.png
% // latex: b^2-a\,b+b+a^2
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-057.png
% // latex: y^2-x\,y+y+x^2
% Such a symbolic function can be used for symbolic variables.
% 
% But the function can also be used for a numerical vector.
>v=[3,4]; f(v)
17
% There are also purely symbolic functions, which cannot be used numerically.
>function lapl(expr,x,y) &&= diff(expr,x,2)+diff(expr,y,2)//turunan parsial kedua

                 diff(expr, y, 2) + diff(expr, x, 2)

>$&realpart((x+I*y)^4), $&lapl(%,x,y)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-058.png
% // latex: y^4-6\,x^2\,y^2+x^4
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-059.png
% // latex: 0
% But of course, they can be used in symbolic expressions or in the definition
% of symbolic functions.
>function f(x,y) &= factor(lapl((x+y^2)^5,x,y)); $&f(x,y)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-060.png
% // latex: 10\,\left(y^2+x\right)^3\,\left(9\,y^2+x+2\right)
% To summarize
% 
% - &= defines symbolic functions,
%% - := defines numerical functions,
%% - &&= defines purely symbolic functions.
% 
% * Solving Expressions
% 
% Expressions can be solved numerically and symbolically.
% 
% To solve a simple expression of one variable, we can use the solve()
% function. It needs a start value to start the search. Internally,
% solve() uses the secant method.
>solve("x^2-2",1)
1.41421356237
% This works for symbolic expression too. Take the following function.
>$&solve(x^2=2,x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-061.png
% // latex: \left[ x=-\sqrt{2} , x=\sqrt{2} \right] 
>$&solve(x^2-2,x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-062.png
% // latex: \left[ x=-\sqrt{2} , x=\sqrt{2} \right] 
>$&solve(a*x^2+b*x+c=0,x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-063.png
% // latex: \left[ x=\frac{-\sqrt{b^2-4\,a\,c}-b}{2\,a} , x=\frac{\sqrt{b^2-4\,  a\,c}-b}{2\,a} \right] 
>$&solve([a*x+b*y=c,d*x+e*y=f],[x,y])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-064.png
% // latex: \left[ \left[ x=-\frac{c\,e}{b\,\left(d-5\right)-a\,e} , y=\frac{c  \,\left(d-5\right)}{b\,\left(d-5\right)-a\,e} \right]  \right] 
>
>
>px &= 4*x^8+x^7-x^4-x; $&px
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-065.png
% // latex: 4\,x^8+x^7-x^4-x
% Now we search the point, where the polynomial is 2. In solve(), the default
% target value y=0 can be changed with an assigned variable.
%% We use y=2 and check by evaluating the polynomial at the previous result.
>solve(px,1,y=2), px(%)
0.966715594851
2
% Solving a symbolic expression in symbolic form returns a list of solutions.
% We use the symbolic solver solve() provided by Maxima.
>sol &= solve(x^2-x-1,x); $&sol
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-066.png
% // latex: \left[ x=\frac{1-\sqrt{5}}{2} , x=\frac{\sqrt{5}+1}{2} \right] 
% The easiest way to get the numerical values is to evaluate the solution
% numerically just like an expression.
>longest sol()
    -0.6180339887498949       1.618033988749895 
% To use the solutions symbolically in other expressions, the easiest way is
% "with".
>$&x^2 with sol[1], $&expand(x^2-x-1 with sol[2])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-067.png
% // latex: \frac{\left(\sqrt{5}-1\right)^2}{4}
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-068.png
% // latex: 0
% 
% Solving systems of equations symbolically can be done with vectors of
% equations and the symbolic solver solve(). The answer is a list of lists of
% equations.
>$&solve([x+y=2,x^3+2*y+x=4],[x,y])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-069.png
% // latex: \left[ \left[ x=-1 , y=3 \right]  , \left[ x=1 , y=1 \right]  ,   \left[ x=0 , y=2 \right]  \right] 
% The function f() can see global variables. But often we want to use
% local parameters.
% 
% latex: a^x-x^a = 0.1
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-070.png
% // latex: a^x-x^a = 0.1
% 
% with a=3.
>function f(x,a) := x^a-a^x;
% One way to pass the additional parameter to f() is to use a list with the
% function name and the parameters (the other way are semicolon parameters).
>solve({{"f",3}},2,y=0.1)
2.54116291558
% This does also work with expressions. But then, a named list element has to
% be used. (More on lists in the tutorial about the syntax of EMT).
>solve({{"x^a-a^x",a=3}},2,y=0.1)
2.54116291558
% * Menyelesaikan Pertidaksamaan
% 
% Untuk menyelesaikan pertidaksamaan, EMT tidak akan dapat melakukannya,
% melainkan dengan bantuan Maxima, artinya secara eksak (simbolik).
% Perintah Maxima yang digunakan adalah fourier_elim(), yang harus
% dipanggil dengan perintah "load(fourier_elim)" terlebih dahulu.
>&load(fourier_elim)

        C:/Program Files/Euler x64/maxima/share/maxima/5.35.1/share/f\
ourier_elim/fourier_elim.lisp

>$&fourier_elim([x^2 - 1>0],[x]) // x^2-1 > 0
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-071.png
% // latex: \left[ 1<x \right] \lor \left[ x<-1 \right] 
>$&fourier_elim([x^2 - 1<0],[x]) // x^2-1 < 0
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-072.png
% // latex: \left[ -1<x , x<1 \right] 
>$&fourier_elim([x^2 - 1 # 0],[x]) // x^-1 <> 0
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-073.png
% // latex: \left[ -1<x , x<1 \right] \lor \left[ 1<x \right] \lor \left[ x<-1   \right] 
>$&fourier_elim([x # 6],[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-074.png
% // latex: \left[ x<6 \right] \lor \left[ 6<x \right] 
>$&fourier_elim([x < 1, x > 1],[x]) // tidak memiliki penyelesaian
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-075.png
% // latex: {\it emptyset}
>$&fourier_elim([minf < x, x < inf],[x]) // solusinya R
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-076.png
% // latex: {\it universalset}
>$&fourier_elim([x^3 - 1 > 0],[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-077.png
% // latex: \left[ 1<x , x^2+x+1>0 \right] \lor \left[ x<1 , -x^2-x-1>0   \right] 
>$&fourier_elim([cos(x) < 1/2],[x]) // ??? gagal
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-078.png
% // latex: \left[ 1-2\,\cos x>0 \right] 
>
>$&fourier_elim([y-x < 5, x - y < 7, 10 < y],[x,y]) // sistem pertidaksamaan
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-079.png
% // latex: \left[ y-5<x , x<y+7 , 10<y \right] 
>$&fourier_elim([y-x < 5, x - y < 7, 10 < y],[y,x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-080.png
% // latex: \left[ {\it max}\left(10 , x-7\right)<y , y<x+5 , 5<x \right] 
>$&fourier_elim((x + y < 5) and (x - y >8),[x,y])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-081.png
% // latex: \left[ y+8<x , x<5-y , y<-\frac{3}{2} \right] 
>$&fourier_elim(((x + y < 5) and x < 1) or  (x - y >8),[x,y])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-082.png
% // latex: \left[ y+8<x \right] \lor \left[ x<{\it min}\left(1 , 5-y\right)   \right] 
>&fourier_elim([max(x,y) > 6, x # 8, abs(y-1) > 12],[x,y])

        [6 < x, x < 8, y < - 11] or [8 < x, y < - 11]
 or [x < 8, 13 < y] or [x = y, 13 < y] or [8 < x, x < y, 13 < y]
 or [y < x, 13 < y]

>$&fourier_elim([(x+6)/(x-9) <= 6],[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-083.png
% // latex: \left[ x=12 \right] \lor \left[ 12<x \right] \lor \left[ x<9   \right] 
>
% * The Matrix Language
% 
% The documentation of the EMT core contains a detailed discussion on the
% matrix language of Euler.
% 
% Vectors and matrices are entered with square brackets, elements separated by
% commas, rows separated by semicolons.
>A=[1,2;3,4]
            1             2 
            3             4 
% The matrix product is denoted by a dot.
>b=[3;4]
            3 
            4 
>b' // transpose b
[3,  4]
>inv(A) //inverse A
           -2             1 
          1.5          -0.5 
>A.b //perkalian matriks
           11 
           25 
>A.inv(A)
            1             0 
            0             1 
% The main point of a matrix language is that all functions and operators work
% element for element.
>A.A
            7            10 
           15            22 
>A^2 //perpangkatan elemen2 A
            1             4 
            9            16 
>A.A.A
           37            54 
           81           118 
>power(A,3) //perpangkatan matriks
           37            54 
           81           118 
>A/A //pembagian elemen-elemen matriks yang seletak
            1             1 
            1             1 
>A/b //pembagian elemen2 A oleh elemen2 b kolom demi kolom (karena b vektor kolom)
     0.333333      0.666667 
         0.75             1 
>A\b // hasilkali invers A dan b, A^(-1)b 
           -2 
          2.5 
>inv(A).b
           -2 
          2.5 
>A\A   //A^(-1)A
            1             0 
            0             1 
>inv(A).A
            1             0 
            0             1 
>A*A //perkalin elemen-elemen matriks seletak
            1             4 
            9            16 
% This is not the matrix product, but a multiplication element by element. The
% same works for vectors.
>b^2 // perpangkatan elemen-elemen matriks/vektor
            9 
           16 
% 
% If one of the operands is a vector or a scalar it is expanded in the
% natural way.
>2*A
            2             4 
            6             8 
% E.g., if the operand is a column vector its elements are applied to
% all rows of A.
>[1,2]*A
            1             4 
            3             8 
% If it is a row vector it is applied to all columns of A.
>A*[2,3]
            2             6 
            6            12 
% One can imagine this multiplication as if the row vector v had been
% duplicated to form a matrix of the same size as A.
>dup([1,2],2) // dup: menduplikasi/menggandakan vektor [1,2] sebanyak 2 kali (baris)
            1             2 
            1             2 
>A*dup([1,2],2) 
            1             4 
            3             8 
% This does also apply for two vectors where one is a row vector and the
% other is a column vector. We compute i*j for i,j from 1 to 5. The trick is to multiply 1:5
% with its transpose. The matrix language of Euler automatically
% generates a table of values.
>(1:5)*(1:5)' // hasilkali elemen-elemen vektor baris dan vektor kolom
            1             2             3             4             5 
            2             4             6             8            10 
            3             6             9            12            15 
            4             8            12            16            20 
            5            10            15            20            25 
% Again, remember that this is not the matrix product!
>(1:5).(1:5)' // hasilkali vektor baris dan vektor kolom
55
>sum((1:5)*(1:5)) // sama hasilnya
55
% Even operators like < or == work in the same way.
>(1:10)<6 // menguji elemen-elemen yang kurang dari 6
[1,  1,  1,  1,  1,  0,  0,  0,  0,  0]
% E.g., we can count the number of elements satisfying a certain
% condition with the function sum().
>sum((1:10)<6) // banyak elemen yang kurang dari 6
5
% Euler has comparison operators, like "==", which checks for equality.
% 
% We get a vector of 0 and 1, where 1 stands for true.
>t=(1:10)^2; t==25 //menguji elemen2 t yang sama dengan 25 (hanya ada 1)
[0,  0,  0,  0,  1,  0,  0,  0,  0,  0]
% From such a vector, "nonzeros" selects the non-zero elements.
% 
% In this case, we get the indices of all elements greater than 50.
>nonzeros(t>50) //indeks elemen2 t yang lebih besar daripada 50
[8,  9,  10]
% Of course, we can use this vector of indices to get the corresponding
% values in t.
>t[nonzeros(t>50)] //elemen2 t yang lebih besar daripada 50
[64,  81,  100]
% As an example, let us find all squares of the numbers 1 to 1000, which
% are 5 modulo 11 and 3 modulo 13.
>t=1:1000; nonzeros(mod(t^2,11)==5 && mod(t^2,13)==3)
[4,  48,  95,  139,  147,  191,  238,  282,  290,  334,  381,  425,
433,  477,  524,  568,  576,  620,  667,  711,  719,  763,  810,  854,
862,  906,  953,  997]
% EMT is not completely effective for integer computations. It uses
% double precision floating point internally. However, it is often very
% useful.
% 
% We can check for primality. Let us find out, how many squares plus 1
% are primes.
>t=1:1000; length(nonzeros(isprime(t^2+1)))
112
% The function nonzeros() works only for vectors. For matrices, there is
% mnonzeros().
>seed(2); A=random(3,4)
     0.765761      0.401188      0.406347      0.267829 
      0.13673      0.390567      0.495975      0.952814 
     0.548138      0.006085      0.444255      0.539246 
% It returns the indices of the elements, which are not zeros.
>k=mnonzeros(A<0.4) //indeks elemen2 A yang kurang dari 0,4
            1             4 
            2             1 
            2             2 
            3             2 
% These indices can be used to set the elements to some value.
>mset(A,k,0) //mengganti elemen2 suatu matriks pada indeks tertentu
     0.765761      0.401188      0.406347             0 
            0             0      0.495975      0.952814 
     0.548138             0      0.444255      0.539246 
% The function mset() can also set the elements at the indices to the
% entries of some other matrix.
>mset(A,k,-random(size(A)))
     0.765761      0.401188      0.406347     -0.126917 
    -0.122404     -0.691673      0.495975      0.952814 
     0.548138     -0.483902      0.444255      0.539246 
% And it is possible to get the elements in a vector.
>mget(A,k)
[0.267829,  0.13673,  0.390567,  0.006085]
% Another useful function is extrema, which returns the minimal and
% maximal values in each row of the matrix and their positions.
>ex=extrema(A)
     0.267829             4      0.765761             1 
      0.13673             1      0.952814             4 
     0.006085             2      0.548138             1 
% We can use this to extract the maximal values in each row.
>ex[,3]'
[0.765761,  0.952814,  0.548138]
% This, of course, is the same as the function max().
>max(A)'
[0.765761,  0.952814,  0.548138]
% But with mget(), we can extract the indices and use this information
% to extract the elements at the same positions from another matrix.
>j=(1:rows(A))'|ex[,4], mget(-A,j)
            1             1 
            2             4 
            3             1 
[-0.765761,  -0.952814,  -0.548138]
% 
% * Other Matrix Functions (Building Matrix)
% 
% To build a matrix, we can stack one matrix on top of another. If both
% do not have the same number of columns, the shorter one will be filled
% with 0.
>v=1:3; v_v
            1             2             3 
            1             2             3 
% Likewise, we can attach a matrix to another side by side, if both have
% the same number of rows.
>A=random(3,4); A|v'
     0.032444     0.0534171      0.595713      0.564454             1 
      0.83916      0.175552      0.396988       0.83514             2 
    0.0257573      0.658585      0.629832      0.770895             3 
% If they do not have the same number of rows the shorter matrix is
% filled with 0.
% 
% There is an exception to this rule. A real number attached to a matrix
% will be used as a column filled with that real number.
>A|1
     0.032444     0.0534171      0.595713      0.564454             1 
      0.83916      0.175552      0.396988       0.83514             1 
    0.0257573      0.658585      0.629832      0.770895             1 
% It is possible to make a matrix of row and column vectors.
>[v;v]
            1             2             3 
            1             2             3 
>[v',v']
            1             1 
            2             2 
            3             3 
% The main purpose of this is to interpret a vector of expressions for
% column vectors.
>"[x,x^2]"(v')
            1             1 
            2             4 
            3             9 
% To get the size of A, we can use the following functions.
>C=zeros(2,4); rows(C), cols(C), size(C), length(C)
2
4
[2,  4]
4
% For vectors, there is length().
>length(2:10)
9
% There are many other functions, which generate matrices.
>ones(2,2)
            1             1 
            1             1 
% This can also be used with one parameter. To get a vector with another
% number than 1, use the following.
>ones(5)*6
[6,  6,  6,  6,  6]
% Also a matrix of random numbers can be generated with random (uniform
% distribution) or normal (Gauß distribution).
>random(2,2)
      0.66566      0.831835 
        0.977      0.544258 
% Here is another useful function, which restructures the elements of a
% matrix into another matrix.
>redim(1:9,3,3) // menyusun elemen2 1, 2, 3, ..., 9 ke bentuk matriks 3x3
            1             2             3 
            4             5             6 
            7             8             9 
% With the following function, we can use this and the dup function to
% write a rep() function, which repeats a vector n times.
>function rep(v,n) := redim(dup(v,n),1,n*cols(v))
% Let us test.
>rep(1:3,5)
[1,  2,  3,  1,  2,  3,  1,  2,  3,  1,  2,  3,  1,  2,  3]
% The function multdup() duplicates elements of a vector.
>multdup(1:3,5), multdup(1:3,[2,3,2])
[1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3]
[1,  1,  2,  2,  2,  3,  3]
% The functions flipx() and flipy() revert the order of the rows or
% columns of a matrix. I.e., the function flipx() flips horizontally.
>flipx(1:5) //membalik elemen2 vektor baris
[5,  4,  3,  2,  1]
% For rotations, Euler has rotleft() and rotright().
>rotleft(1:5) // memutar elemen2 vektor baris
[2,  3,  4,  5,  1]
% A special function is drop(v,i), which removes the elements with the
% indices in i from the vector v.
>drop(10:20,3)
[10,  11,  13,  14,  15,  16,  17,  18,  19,  20]
% Note that the vector i in drop(v,i) refers to indices of elements in
% v, not the values of the elements. If you want to remove elements, you
% need to find the elements first. The function indexof(v,x) can be used
% to find elements x in a sorted vector v.
>v=primes(50), i=indexof(v,10:20), drop(v,i)
[2,  3,  5,  7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43,  47]
[0,  5,  0,  6,  0,  0,  0,  7,  0,  8,  0]
[2,  3,  5,  7,  23,  29,  31,  37,  41,  43,  47]
% As you see, it does not harm to include indices out of range (like 0),
% double indices, or unsorted indices.
>drop(1:10,shuffle([0,0,5,5,7,12,12]))
[1,  2,  3,  4,  6,  8,  9,  10]
% There are some special functions to set diagonals or to generate a
% diagonal matrix.
% 
% We start with the identity matrix.
>A=id(5) // matriks identitas 5x5
            1             0             0             0             0 
            0             1             0             0             0 
            0             0             1             0             0 
            0             0             0             1             0 
            0             0             0             0             1 
% Then we set the lower diagonal (-1) to 1:4.
>setdiag(A,-1,1:4) //mengganti diagonal di bawah diagonal utama
            1             0             0             0             0 
            1             1             0             0             0 
            0             2             1             0             0 
            0             0             3             1             0 
            0             0             0             4             1 
% Note that we did not change the matrix A. We get a new matrix as
% result of setdiag().
% 
% Here is a function, which returns a tri-diagonal matrix.
>function tridiag (n,a,b,c) := setdiag(setdiag(b*id(n),1,c),-1,a); ...
>tridiag(5,1,2,3)
            2             3             0             0             0 
            1             2             3             0             0 
            0             1             2             3             0 
            0             0             1             2             3 
            0             0             0             1             2 
% The diagonal of a matrix can also be extracted from the matrix. To
% demonstrate this, we restructure the vector 1:9 to a 3x3 matrix.
>A=redim(1:9,3,3)
            1             2             3 
            4             5             6 
            7             8             9 
% Now we can extract the diagonal.
>d=getdiag(A,0)
[1,  5,  9]
% E.g. We can divide the matrix by its diagonal. The matrix language
% takes care that the column vector d is applied to the matrix row by
% row.
>fraction A/d'
        1         2         3 
      4/5         1       6/5 
      7/9       8/9         1 
% * Vectorization
% 
% Almost all functions in Euler work for matrix and vector input too,
% whenever this makes sense.
% 
% E.g., the sqrt() function computes the square root of all elements of
% the vector or matrix.
>sqrt(1:3)
[1,  1.41421,  1.73205]
% So you can easily create a table of values. This is one way to plot a
% function (the alternative uses an expression).
>x=1:0.01:5; y=log(x)/x^2; // terlalu panjang untuk ditampikan
% With this and the colon operator a:delta:b, vectors of values of functions
% can be generated easily.
% 
% In the following example, we generate a vector of values t[i] with spacing
% 0.1 from -1 to 1. Then we generate a vector of values of the function
% 
% latex: s = t^3-t
>t=-1:0.1:1; s=t^3-t
[0,  0.171,  0.288,  0.357,  0.384,  0.375,  0.336,  0.273,  0.192,
0.099,  0,  -0.099,  -0.192,  -0.273,  -0.336,  -0.375,  -0.384,
-0.357,  -0.288,  -0.171,  0]
% EMT expands operators for scalars, vectors, and matrices in the obvious way.
% 
% E.g., a column vector times a row vector expands to matrix, if an an operator
% is applied. In the following, v' is the transposed vector (a column vector).
>shortest (1:5)*(1:5)'
     1      2      3      4      5 
     2      4      6      8     10 
     3      6      9     12     15 
     4      8     12     16     20 
     5     10     15     20     25 
% Note, that this is quite different from the matrix product. The matrix
% product is denoted with a dot "." in EMT.
>(1:5).(1:5)'
55
% 
% By default, row vectors are printed in a compact format.
>[1,2,3,4]
[1,  2,  3,  4]
% For matrices the special operator . denotes matrix multiplication, and A'
% denotes transposing. A 1x1 matrix can be used just like a real number.
>v:=[1,2]; v.v', %^2
5
25
% To transpose a matrix we use the apostrophe.
>v=1:4; v'
            1 
            2 
            3 
            4 
% So we can compute matrix A times vector b.
>A=[1,2,3,4;5,6,7,8]; A.v'
           30 
           70 
% Note that v is still a row vector. So v'.v is different from v.v'.
>v'.v
            1             2             3             4 
            2             4             6             8 
            3             6             9            12 
            4             8            12            16 
% v.v' computes the norm of v squared for row vectors v. The result is a
% 1x1 vector, which works just like a real number.
>v.v'
30
% There is also the function norm (along with many other function of
% Linear Algebra).
>norm(v)^2
30
% Operators and functions obey the matrix language of Euler.
% 
% Here is a summary of the rules.
% 
% - A function applied to a vector or matrix is applied to each element.
% 
% - An operator operating on two matrices of same size is applied pairwise to
% the elements of the matrices.
% 
% - If the two matrices have different dimensions, both are expanded in a
% sensible way, so that they have the same size.
% 
% E.g., a scalar value times a vector multiplies the value with each element of
% the vector. Or a matrix times a vector (with *, not .) expands the vector to
% the size of the matrix by duplicating it.
% 
% The following is a simple case with the operator ^.
>[1,2,3]^2
[1,  4,  9]
% Here is a more complicated case. A row vector times a column vector expands
% both by duplicating.
>v:=[1,2,3]; v*v'
            1             2             3 
            2             4             6 
            3             6             9 
% Note that the scalar product uses the matrix product, not the *!
>v.v'
14
% There are numerous functions for matrices. We give a short list. You should to consult
% the documentation for more information on these commands.
% 
%   sum,prod computes the sum and products of the rows
%%   cumsum,cumprod does the same cumulatively
%%   computes the extremal values of each row
%%   extrema returns a vector with the extremal information
%%   diag(A,i) returns the i-th diagonal
%%   setdiag(A,i,v) sets the i-th diagonal
%%   id(n) the identity matrix
%%   det(A) the determinant
%%   charpoly(A) the characteristic polynomial
%%   eigenvalues(A) the eigenvalues
>v*v, sum(v*v), cumsum(v*v)
[1,  4,  9]
14
[1,  5,  14]
% The : operator generates an equally spaces row vector, optionally with a step
% size.
>1:4, 1:2:10
[1,  2,  3,  4]
[1,  3,  5,  7,  9]
% To concatenate matrices and vectors there are the operators "|" and "_".
>[1,2,3]|[4,5], [1,2,3]_1
[1,  2,  3,  4,  5]
            1             2             3 
            1             1             1 
% The elements of a matrix are referred with "A[i,j]".
>A:=[1,2,3;4,5,6;7,8,9]; A[2,3]
6
% For row or column vectors, v[i] is the i-th element of the vector. For
% matrices, this returns the complete i-th row of the matrix.
>v:=[2,4,6,8]; v[3], A[3]
6
[7,  8,  9]
% The indices can also be row vectors of indices. : denotes all indices.
>v[1:2], A[:,2]
[2,  4]
            2 
            5 
            8 
% A short form for : is omitting the index completely.
>A[,2:3]
            2             3 
            5             6 
            8             9 
% For purposes of vectorization, the elements of a matrix can be accessed as if
% they were vectors.
>A{4}
4
% A matrix can also be flattened, using the redim() function. This is
% implemented in the function flatten().
>redim(A,1,prod(size(A))), flatten(A)
[1,  2,  3,  4,  5,  6,  7,  8,  9]
[1,  2,  3,  4,  5,  6,  7,  8,  9]
% 
% To use matrices for tables, let us reset to the default format, and
% compute a table of sine and cosine values. Note that angles are in
% radians by default.
>defformat; w=0°:45°:360°; w=w'; deg(w)
            0 
           45 
           90 
          135 
          180 
          225 
          270 
          315 
          360 
% Now we append columns to a matrix.
>M = deg(w)|w|cos(w)|sin(w)
            0             0             1             0 
           45      0.785398      0.707107      0.707107 
           90        1.5708             0             1 
          135       2.35619     -0.707107      0.707107 
          180       3.14159            -1             0 
          225       3.92699     -0.707107     -0.707107 
          270       4.71239             0            -1 
          315       5.49779      0.707107     -0.707107 
          360       6.28319             1             0 
% 
% Using the matrix language, we can generate several tables of several
% functions at once.
% 
% In the following example, we compute t[j]^i for i from 1 to n. We get a matrix,
% where each row is a table of t^i for one i. I.e., the matrix has the
% elements
% latex: a_{i,j} = t_j^i, \quad 1 \le j \le 101, \quad 1 \le i \le n
% 
% A function which does not work for vector input should be "vectorized". This
% can be achieved by the "map" keyword in the function definition. Then the
% function will be evaluated for each element of a vector parameter.
% 
% The numerical integration integrate() works only for scalar interval bounds.
% So we need to vectorize it.
>function map f(x) := integrate("x^x",1,x)
% The "map" keyword vectorizes the function. The function will now work
%% for vectors of numbers.
>f([1:5])
[0,  2.05045,  13.7251,  113.336,  1241.03]
% * Sub-Matrices and Matrix-Elements
% 
% To access a matrix element, use the bracket notation.
>A=[1,2,3;4,5,6;7,8,9], A[2,2]
            1             2             3 
            4             5             6 
            7             8             9 
5
% We can access a complete line of a matrix.
>A[2]
[4,  5,  6]
% In case of row or column vectors, this returns an element of the
% vector.
>v=1:3; v[2]
2
% To make sure, you get the first row for a 1xn and a mxn matrix,
% specify all columns using an empty second index.
>A[2,]
[4,  5,  6]
% If the index is a vector of indices, Euler will return the
% corresponding rows of the matrix.
% 
% Here we want the first and second row of A.
>A[[1,2]]
            1             2             3 
            4             5             6 
% We can even reorder A using vectors of indices. To be precise, we do
% not change A here, but compute a reordered version of A.
>A[[3,2,1]]
            7             8             9 
            4             5             6 
            1             2             3 
% The index trick works with columns too.
% 
% This example selects all rows of A and the second and third column.
>A[1:3,2:3]
            2             3 
            5             6 
            8             9 
% For abbreviation ":" denotes all row or column indices.
>A[:,3]
            3 
            6 
            9 
% Alternatively, leave the first index empty.
>A[,2:3]
            2             3 
            5             6 
            8             9 
% We can also get the last line of A.
>A[-1]
[7,  8,  9]
% Now let us change elements of A by assigning a submatrix of A to some
% value. This does in fact change the stored matrix A.
>A[1,1]=4
            4             2             3 
            4             5             6 
            7             8             9 
% We can also assign a value to a row of A.
>A[1]=[-1,-1,-1]
           -1            -1            -1 
            4             5             6 
            7             8             9 
% We can even assign to a sub-matrix if it has the proper size.
>A[1:2,1:2]=[5,6;7,8]
            5             6            -1 
            7             8             6 
            7             8             9 
% Moreover, some shortcuts are allowed.
>A[1:2,1:2]=0
            0             0            -1 
            0             0             6 
            7             8             9 
% A warning: Indices out of bounds return empty matrices, or an error
% message, depending on a system setting. The default is an error
% message. Remember, however, that negative indices may be used to
% access the elements of a matrix counting from the end.
>A[4]
Row index 4 out of bounds!
Error in:
A[4] ...
    ^
% * Sorting and Shuffling
% 
% The function sort() sorts a row vector.
>sort([5,6,4,8,1,9])
[1,  4,  5,  6,  8,  9]
% It is often necessary to know the indices of the sorted vector in the
% original vector. This can be used to reorder another vector in the
% same way.
% 
% Let us shuffle a vector.
>v=shuffle(1:10)
[4,  5,  10,  6,  8,  9,  1,  7,  2,  3]
% The indices contain the proper order of v.
>{vs,ind}=sort(v); v[ind]
[1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
% This works for string vectors too.
>s=["a","d","e","a","aa","e"]
a
d
e
a
aa
e
>{ss,ind}=sort(s); ss
a
a
aa
d
e
e
% As you see, the position of double entries is somewhat random.
>ind
[4,  1,  5,  2,  6,  3]
% The function unique returns a sorted list of unique elements of a
% vector.
>intrandom(1,10,10), unique(%)
[4,  4,  9,  2,  6,  5,  10,  6,  5,  1]
[1,  2,  4,  5,  6,  9,  10]
% This works for string vectors too.
>unique(s)
a
aa
d
e
% * Linear Algebra
% 
% EMT has lots of functions to solve linear systems, sparse systems, or
% regression problems.
% 
% For linear systems Ax=b, you can use the Gauss algorithm, the inverse matrix
% or a linear fit. The operator A\b uses a version of the Gauss algorithm.
>A=[1,2;3,4]; b=[5;6]; A\b
           -4 
          4.5 
% For another example, we generate a 200x200 matrix and the sum of its rows.
% Then we solve Ax=b using the inverse matrix. We measure the error as the
% maximal deviation of all elements from 1, which of course is the correct
% solution.
>A=normal(200,200); b=sum(A); longest totalmax(abs(inv(A).b-1))
  8.790745908981989e-13 
% If the system does not have a solution, a linear fit minimizes the norm of
% the error Ax-b.
>A=[1,2,3;4,5,6;7,8,9]
            1             2             3 
            4             5             6 
            7             8             9 
% The determinant of this matrix is 0.
>det(A)
0
% * Symbolic Matrices
% 
% Maxima has symbolic matrices. Of course, Maxima can be used for such simple linear algebra problems.
% We can define the matrix for Euler and Maxima with &:=, and then use
% it in symbolic expressions.
% The usual [...] form to define matrices can be used in Euler to define symbolic
% matrices.
>A &= [a,1,1;1,a,1;1,1,a]; $A
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-084.png
% // latex: \begin{pmatrix}a & 1 & 1 \\ 1 & a & 1 \\ 1 & 1 & a \\ \end{pmatrix}
>$&det(A), $&factor(%)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-085.png
% // latex: a\,\left(a^2-1\right)-2\,a+2
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-086.png
% // latex: \left(a-1\right)^2\,\left(a+2\right)
>$&invert(A) with a=0
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-087.png
% // latex: \begin{pmatrix}-\frac{1}{2} & \frac{1}{2} & \frac{1}{2} \\ \frac{1  }{2} & -\frac{1}{2} & \frac{1}{2} \\ \frac{1}{2} & \frac{1}{2} & -  \frac{1}{2} \\ \end{pmatrix}
>A &= [1,a;b,2]; $A
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-088.png
% // latex: \begin{pmatrix}1 & a \\ b & 2 \\ \end{pmatrix}
% Like all symbolic variables, these matrices can be used in other
% symbolic expressions.
>$&det(A-x*ident(2)), $&solve(%,x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-089.png
% // latex: \left(1-x\right)\,\left(2-x\right)-a\,b
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-090.png
% // latex: \left[ x=\frac{3-\sqrt{4\,a\,b+1}}{2} , x=\frac{\sqrt{4\,a\,b+1}+3  }{2} \right] 
% The eigenvalues can also be computed automatically. The result is a
% vector with two vectors of eigenvalues and multiplicities.
>$&eigenvalues([a,1;1,a])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-091.png
% // latex: \left[ \left[ a-1 , a+1 \right]  , \left[ 1 , 1 \right]  \right] 
% To extract a specific eigenvector needs careful indexing.
>$&eigenvectors([a,1;1,a]), &%[2][1][1]
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-092.png
% // latex: \left[ \left[ \left[ a-1 , a+1 \right]  , \left[ 1 , 1 \right]    \right]  , \left[ \left[ \left[ 1 , -1 \right]  \right]  , \left[   \left[ 1 , 1 \right]  \right]  \right]  \right] 

                               [1, - 1]

% Symbolic matrices can be evaluated in Euler numerically just like
% other symbolic expressions.
>A(a=4,b=5)
            1             4 
            5             2 
% In symbolic expressions, use with.
>$&A with [a=4,b=5]
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-093.png
% // latex: \begin{pmatrix}1 & 4 \\ 5 & 2 \\ \end{pmatrix}
% Access to rows of symbolic matrices work just like with numerical
% matrices.
>$&A[1]
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-094.png
% // latex: \left[ 1 , a \right] 
% A symbolic expression can contain an assignment. And that changes the
% matrix A.
>&A[1,1]:=t+1; $&A
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-095.png
% // latex: \begin{pmatrix}t+1 & a \\ b & 2 \\ \end{pmatrix}
% There are symbolic functions in Maxima to create vectors and matrices.
% For this, refer to the documentation of Maxima or to the tutorial
% about Maxima in EMT.
>v &= makelist(1/(i+j),i,1,3); $v
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-096.png
% // latex: \left[ \frac{1}{j+1} , \frac{1}{j+2} , \frac{1}{j+3} \right] 
%  
>B &:= [1,2;3,4]; $B, $&invert(B)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-097.png
% // latex: \begin{pmatrix}1 & 2 \\ 3 & 4 \\ \end{pmatrix}
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-098.png
% // latex: \begin{pmatrix}-2 & 1 \\ \frac{3}{2} & -\frac{1}{2} \\   \end{pmatrix}
% The result can be evaluated numerically in Euler. For more information
% about Maxima, see the introduction to Maxima.
>$&invert(B)()
           -2             1 
          1.5          -0.5 
% Euler has also a powerful function xinv(), which makes a bigger effort
% and gets more exact results.
% 
% Note, that with &:= the matrix B has been defined as symbolic in
% symbolic expressions and as numerical in numerical expressions. So we
% can use it here.
>longest B.xinv(B)
                      1                       0 
                      0                       1 
% E.g. the eigenvalues of A can be computed numerically.
>A=[1,2,3;4,5,6;7,8,9]; real(eigenvalues(A))
[16.1168,  -1.11684,  0]
% Or symbolically. See the tutorial about Maxima for details on this.
>$&eigenvalues(@A)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-099.png
% // latex: \left[ \left[ \frac{15-3\,\sqrt{33}}{2} , \frac{3\,\sqrt{33}+15}{2}   , 0 \right]  , \left[ 1 , 1 , 1 \right]  \right] 
% * Numerical Values in symbolic Expressions
% 
% A symbolic expression is just a string containing an expression. If we
% want to define a value both for symbolic expressions and for numerical
% expressions, we must use "&:=".
>A &:= [1,pi;4,5]
            1       3.14159 
            4             5 
% There is still a difference between the numerical and the symbolic
% form. When transferring the matrix to the symbolic form, fractional
% approximations for reals will be used.
>$&A
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-100.png
% // latex: \begin{pmatrix}1 & \frac{1146408}{364913} \\ 4 & 5 \\ \end{pmatrix}
% To avoid this, there is the function "mxmset(variable)".
>mxmset(A); $&A
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-101.png
% // latex: \begin{pmatrix}1 & 3.141592653589793 \\ 4 & 5 \\ \end{pmatrix}
% Maxima can also compute with floating point numbers, and even with big
% floating numbers with 32 digits. The evaluation is much slower,
% however.
>$&bfloat(sqrt(2)), $&float(sqrt(2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-102.png
% // latex: 1.4142135623730950488016887242097_B \times 10^{0}
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-103.png
% // latex: 1.414213562373095
% The precision of the big floating point numbers can be changed.
>&fpprec:=100; &bfloat(pi)

        3.14159265358979323846264338327950288419716939937510582097494\
4592307816406286208998628034825342117068b0

% A numerical variable can be used in any symbolic expressions using
% "@var".
% 
% Note that this is only necessary, if the variable has been defined
% with ":=" or "=" as a numerical variable.
>B:=[1,pi;3,4]; $&det(@B)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-104.png
% // latex: -5.424777960769379
% 
% * Demo - Interest Rates
% 
% Below, we use Euler Math Toolbox (EMT) for the calculation of interest rates.
% We do that numerically and symbolically to show you how Euler can be used to
% solve real life problems.
% 
% Assume you have a seed capital of 5000 (say in dollars).
>K=5000
5000
% Now we assume an interest rate of 3% per year. Let us add one simple rate and
% compute the result.
>K*1.03
5150
% Euler would understand the following syntax too.
>K+K*3%
5150
% But it is easier to use the factor
>q=1+3%, K*q
1.03
5150
% For 10 years, we can simply multiply the factors and get the final value with
% compound interest rates.
>K*q^10
6719.58189672
% For our purposes, we can set the format to 2 digits after the decimal dot.
>format(12,2); K*q^10
    6719.58 
% Let us print that rounded to 2 digits in a complete sentence.
>"Starting from " + K + "$ you get " + round(K*q^10,2) + "$."
Starting from 5000$ you get 6719.58$.
% What if we want to know the intermediate results from year 1 to year 9? For
% this, Euler's matrix language is a big help. You do not have to write a loop,
% but simply enter
>K*q^(0:10)
Real 1 x 11 matrix

    5000.00     5150.00     5304.50     5463.64     ...
% How does this miracle work? First the expression 0:10 returns a vector of
% integers.
>short 0:10
[0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
% Then all operators and functions in Euler can be applied to vectors element
% for element. So
>short q^(0:10)
[1,  1.03,  1.0609,  1.0927,  1.1255,  1.1593,  1.1941,  1.2299,
1.2668,  1.3048,  1.3439]
% is a vector of factors q^0 to q^10. This is multiplied by K, and we get the
% vector of values.
>VK=K*q^(0:10);
% Of course, the realistic way to compute these interest rates would be to
% round to the nearest cent after each year. Let us add a function for this.
>function oneyear (K) := round(K*q,2)
% Let us compare the two results, with and without rounding.
>longest oneyear(1234.57), longest 1234.57*q
                1271.61 
              1271.6071 
% Now there is no simple formula for the n-th year, and we must loop over the
% years. Euler provides many solutions for this.
% 
% The easiest way is the function iterate, which iterates a given function a
% number of times.
>VKr=iterate("oneyear",5000,10)
Real 1 x 11 matrix

    5000.00     5150.00     5304.50     5463.64     ...
% We can print that in a friendly way, using our format with fixed decimal
% places.
>VKr'
    5000.00 
    5150.00 
    5304.50 
    5463.64 
    5627.55 
    5796.38 
    5970.27 
    6149.38 
    6333.86 
    6523.88 
    6719.60 
% To get a specific element of the vector, we use indices in square brackets.
>VKr[2], VKr[1:3]
    5150.00 
    5000.00     5150.00     5304.50 
% Surprisingly, we can also use a vector of indices. Remember that 1:3 produced
% the vector [1,2,3].
% 
% Let us compare the last element of the rounded values with the full values.
>VKr[-1], VK[-1]
    6719.60 
    6719.58 
% The difference is very small.
% 
% * Solving Equations
% 
% Now we take a more advanced function, which adds a certain rate of money each
% year.
>function onepay (K) := K*q+R
% We do not have to specify q or R for the definition of the function. Only if
% we run the command, we have to define these values. We select R=200.
>R=200; iterate("onepay",5000,10)
Real 1 x 11 matrix

    5000.00     5350.00     5710.50     6081.82     ...
% What if we remove the same amount each year?
>R=-200; iterate("onepay",5000,10)
Real 1 x 11 matrix

    5000.00     4950.00     4898.50     4845.45     ...
% We see that the money decreases. Obviously, if we get only 150 of interest in
% the first year, but remove 200, we lose money each year.
% 
% How can we determine the number of years the money will last? We would have
% to write a loop for this. The easiest way is to iterate long enough.
>VKR=iterate("onepay",5000,50)
Real 1 x 51 matrix

    5000.00     4950.00     4898.50     4845.45     ...
% Using the matrix language, we can determine the first negative value in the
% following way.
>min(nonzeros(VKR<0))
      48.00 
% The reason for this is that nonzeros(VKR<0) returns a vector of indices i,
% where VKR[i]<0, and min computes the minimal index.
% 
% Since vectors always start with index 1, the answer is 47 years.
% 
% The function iterate() has one more trick. It can take an end condition as an
% argument. Then it will return the value and the number of iterations.
>{x,n}=iterate("onepay",5000,till="x<0"); x, n,
     -19.83 
      47.00 
% Let us try to answer a more ambiguous question. Assume we know that the value
% is 0 after 50 years. What would be the interest rate?
% 
% This is a question, which can only be answered numerically. Below, we will
% derive the necessary formulas. Then you will see that there is no easy
% formula for the interest rate. But for now, we aim for a numerical solution.
% 
% The first step is to define a function which does the iteration n times. We
% add all parameters to this function.
>function f(K,R,P,n) := iterate("x*(1+P/100)+R",K,n;P,R)[-1]
% The iteration is just as above
% 
% latex: x_{n+1} = x_n \cdot \left(1+ \frac{P}{100}\right) + R
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-105.png
% // latex: x_{n+1} = x_n \cdot \left(1+ \frac{P}{100}\right) + R
% 
% But we do longer use the global value of R in our expression.
% Functions like iterate() have a special trick in Euler. You can pass
% the values of variables in the expression as semicolon parameters. In
% this case P and R.
% 
% Moreover, we are only interested in the last value. So we take the
% index [-1].
% 
% Let us try a test.
>f(5000,-200,3,47)
     -19.83 
% Now we can solve our problem.
>solve("f(5000,-200,x,50)",3)
       3.15 
% The solve routine solves expression=0 for the variable x. The answer is 3.15%
% per year. We take the start value of 3% for the algorithm. The solve()
% function always needs a start value.
% 
% We can use the same function to solve the following question: How much can we
% remove per year so that the seed capital is exhausted after 20 years assuming
% an interest rate of 3% per year.
>solve("f(5000,x,3,20)",-200)
    -336.08 
% Note that you cannot solve for the number of years, since our function
% assumes n to be an integer value.
% 
% ** Solusi Simbolis Masalah Suku Bunga
% 
% Kita dapat menggunakan bagian simbolis dari Euler untuk mempelajari
% masalahnya. Pertama kita mendefinisikan fungsi onepay() kita secara
% simbolis.
>function op(K) &= K*q+R; $&op(K)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-106.png
% // latex: R+q\,K
% Sekarang kita dapat mengulanginya.
>$&op(op(op(op(K)))), $&expand
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-107.png
% // latex: q\,\left(q\,\left(q\,\left(R+q\,K\right)+R\right)+R\right)+R
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-108.png
% // latex: {\it expand}
% Kita melihat sebuah pola. Setelah n periode yang kita miliki
% 
% latex: Kn = q^n K + R (1+q+\ldots+q^{n-1}) = q^n K + \frac{q^n-1}{q-1} R
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-109.png
% // latex: Kn = q^n K + R (1+q+\ldots+q^{n-1}) = q^n K + \frac{q^n-1}{q-1} R
% 
% Rumusnya adalah rumus jumlah geometri yang diketahui Maxima.
%% uk mempelajari masalahnya. Pertama kita mendefinisikan fungsi onepay()
% kita secara simbolis.
>&sum(q^k,k,0,n-1); $& % = ev(%,simpsum)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-110.png
% // latex: \sum_{k=0}^{n-1}{q^{k}}=\frac{q^{n}-1}{q-1}
% Ini agak rumit. Jumlahnya dievaluasi dengan tanda "simpsum" untuk
% menguranginya menjadi hasil bagi. Mari kita membuat fungsi untuk ini.
>function fs(K,R,P,n) &= (1+P/100)^n*K + ((1+P/100)^n-1)/(P/100)*R; $&fs(K,R,P,n)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-111.png
% // latex: \frac{100\,\left(\left(\frac{P}{100}+1\right)^{n}-1\right)\,R}{P}+K  \,\left(\frac{P}{100}+1\right)^{n}
% Fungsinya sama dengan fungsi f kita sebelumnya. Tapi ini lebih
% efektif.
>longest f(5000,-200,3,47), longest fs(5000,-200,3,47)
     -19.82504734650985 
     -19.82504734652684 
% Sekarang kita dapat menggunakannya untuk menanyakan waktu n. Kapan
% modal kita habis? Perkiraan awal kami adalah 30 tahun.
>solve("fs(5000,-330,3,x)",30)
      20.51 
% Jawaban ini mengatakan akan menjadi negatif setelah 21 tahun.
% 
% Kita juga dapat menggunakan sisi simbolis Euler untuk menghitung rumus
% pembayaran.
% 
% Asumsikan kita mendapatkan pinjaman sebesar K, dan membayar n
% pembayaran sebesar R (dimulai setelah tahun pertama)  meninggalkan
% sisa hutang sebesar Kn (pada saat pembayaran terakhir). Rumusnya jelas
>equ &= fs(K,R,P,n)=Kn; $&equ
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-112.png
% // latex: \frac{100\,\left(\left(\frac{P}{100}+1\right)^{n}-1\right)\,R}{P}+K  \,\left(\frac{P}{100}+1\right)^{n}={\it Kn}
% Biasanya rumus ini diberikan dalam bentuk:
% 
% latex: i = \frac{P}{100}
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-113.png
% // latex: i = \frac{P}{100}
>equ &= (equ with P=100*i); $&equ
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-114.png
% // latex: \frac{\left(\left(i+1\right)^{n}-1\right)\,R}{i}+\left(i+1\right)^{  n}\,K={\it Kn}
% Kita dapat menyelesaikan nilai R secara simbolis.
>$&solve(equ,R)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-115.png
% // latex: \left[ R=\frac{i\,{\it Kn}-i\,\left(i+1\right)^{n}\,K}{\left(i+1  \right)^{n}-1} \right] 
% Seperti yang Anda lihat dari rumusnya, fungsi ini mengembalikan
% kesalahan floating point untuk i=0. Euler tetap merencanakannya.
% 
% 
% entu saja kita memiliki limit berikut
>$&limit(R(5000,0,x,10),x,0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-116.png
% // latex: \lim_{x\rightarrow 0}{R\left(5000 , 0 , x , 10\right)}
% Yang jelas tanpa bunga kita harus membayar kembali 10 tarif 500.
% 
% Persamaan tersebut juga dapat diselesaikan untuk n. Akan terlihat
% lebih bagus jika kita menerapkan beberapa penyederhanaan padanya.
>fn &= solve(equ,n) | ratsimp; $&fn
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-117.png
% // latex: \left[ n=\frac{\log \left(\frac{R+i\,{\it Kn}}{R+i\,K}\right)}{  \log \left(i+1\right)} \right] 
>
% ** Latihan Soal R2
% 
% 
% Soal No. 49
%% latex: \left(\frac{24a^{10}b^{-8}c^7}{12a^6b^{-3}c^5}\right)^{-5}
% %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-118.png
% // latex: \left(\frac{24a^{10}b^{-8}c^7}{12a^6b^{-3}c^5}\right)^{-5}
>$&((24*a^10*b^(-8)*c^7)/(12*a^6*b^(-3)*c^5))^(-5)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-119.png
% // latex: \frac{b^{25}}{32\,a^{20}\,c^{10}}
% Soal No. 50
>$&((125*p^12*q^(-14)*r^22)/(25*p^8*q^6*r^(-15)))^(-4)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-120.png
% // latex: \frac{q^{80}}{625\,p^{16}\,r^{148}}
>$&(2^6*2^(-3)/(2^10)/(2^(-8)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-121.png
% // latex: 2
% Soal No. 91
>$&(4*(8-6)^2-4*3+2*8)/(3^1+19^0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-122.png
% // latex: 5
% Soal No. 92
>$&((4*(8-6)^2+4)*(3-2*8))/(2^2*(2^3+5))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-123.png
% // latex: -5
% Soal No. 104
>$&((m^(x-b)*n(x+b)^x)*(m^b*n^(-b))^x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-124.png
% // latex: m^{x-b}\,\left(\frac{m^{b}}{n^{b}}\right)^{x}\,n^{x}\left(x+b  \right)
% ** Latihan Soal R3
%% Soal No. 9
>$&((3*x^2-2*x-x^3+2)-(5*x^2-8*x-x^3+4))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-125.png
% // latex: -2\,x^2+6\,x-2
% Soal No. 13
>$&((3*a^2)*((-7)*a^4))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-126.png
% // latex: -21\,a^6
% Soal No. 14
>$&((8*y^5)*(9*y))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-127.png
% // latex: 72\,y^6
% Soal No. 15
>$&((6*x*y^3)*(9*x^4*y^2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-128.png
% // latex: 54\,x^5\,y^5
% Soal. No 36
>$%((4*x^2-5*y)^2)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-129.png
% // latex: \left(54\,x^5\,y^5\right)(\left(4\,x^2-5\,y\right)^2)
% ** Latihan Soal R4
% 
% Soal No. 23
>$& factor(t^2+8*t+15)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-130.png
% // latex: \left(t+3\right)\,\left(t+5\right)
% Soal No. 24
>$& factor(y^2+12*y+27)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-131.png
% // latex: \left(y+3\right)\,\left(y+9\right)
% Soal No. 121
>$& factor(y^4-84+5*y^2)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-132.png
% // latex: \left(y^2-7\right)\,\left(y^2+12\right)
% Soal No. 77
>$& factor((18*a^2*b)-(15*a*b^2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-133.png
% // latex: -3\,a\,b\,\left(5\,b-6\,a\right)
% Soal No. 78
>$& factor(4*x^2*y+12*x*y^2)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-134.png
% // latex: 4\,x\,y\,\left(3\,y+x\right)
% ** Latihan Soal R5
% 
% Soal No. 31
>$& solve(7*(3*x+6)= 11-(x+2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-135.png
% // latex: \left[ x=-\frac{3}{2} \right] 
% Soal No. 32
>$& solve(9*(2*x+8)= 20-(x-5))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-136.png
% // latex: \left[ x=-\frac{47}{19} \right] 
% Soal No. 35
>$& solve(x^2+3*x-28=0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-137.png
% // latex: \left[ x=4 , x=-7 \right] 
% Soal No. 36
>$& solve(y^2-4*y-45=0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-138.png
% // latex: \left[ y=9 , y=-5 \right] 
% Soal No. 37
>$& solve(x^2+5*x=0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-139.png
% // latex: \left[ x=-5 , x=0 \right] 
% ** Latihan Soal R6
% 
% Soal No. 9
>$&ratsimp((x^2-4)/(x^2-4*x+4))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-140.png
% // latex: \frac{x+2}{x-2}
% Soal No. 11
>$&ratsimp((x^3-6*x^2+9*x)/(x^3-3*x^2))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-141.png
% // latex: \frac{x-3}{x}
% Soal No. 14
>$&ratsimp((2*x^2-20*x+50)/(10*x^2-30*x-100))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-142.png
% // latex: \frac{x-5}{5\,x+10}
% Soal No. 15
>$&ratsimp((6-x)/(x^2-36))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-143.png
% // latex: -\frac{1}{x+6}
% Soal No. 20
>$&ratsimp(((x^2-2*x-35)/(2*x^3-3*x^2))*((4*x^3-9*x)/(7*x-49)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-144.png
% // latex: \frac{2\,x^2+13\,x+15}{7\,x}
% ** Latihan soal 3.1
% 
% Soal No. 11
>$ powerdisp: true
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-145.png
% // latex: \mathbf{true}
> $&((-5+3*I)+(7+8*I))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-146.png
% // latex: 2+11\,i
% Soal No. 31
> $& (sqrt(-4)*(sqrt(-36)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-147.png
% // latex: -12
% Soal No. 53
>$& solve(2*x^2+1=5*x)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-148.png
% // latex: \left[ x=\frac{5-\sqrt{17}}{4} , x=\frac{5+\sqrt{17}}{4} \right] 
% Soal No. 84
>$& solve(y^4-15*y^2-16=0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-149.png
% // latex: \left[ y=-i , y=i , y=-4 , y=4 \right] 
% Soal No. 79
>$& solve(x^4-3*x^2+2=0)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-150.png
% // latex: \left[ x=-\sqrt{2} , x=\sqrt{2} , x=-1 , x=1 \right] 
% ** Latihan Soal 3.4
% 
% Soal No. 01
>$& solve((1/4)+(1/5)=(1/t))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-151.png
% // latex: \left[ t=\frac{20}{9} \right] 
% Soal No. 9
>$& solve(x+(6/x)=5)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-152.png
% // latex: \left[ x=3 , x=2 \right] 
% Soal No. 15
>$& solve((2/(x+5))+(1/(x-5))=(16/(x^2-25)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-153.png
% // latex: \left[ x=7 \right] 
% Soal No. 29
>$& solve(sqrt(3*x-4)=1)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-154.png
% // latex: \left[ x=\frac{5}{3} \right] 
% Soal No. 33
>$& solve(sqrt(2*x-5)=2)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-155.png
% // latex: \left[ x=\frac{9}{2} \right] 
% ** Latihan Soal 3.5
% 
% Soal NO. 23
>$& solve(abs(x+3)-2=8,[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-156.png
% // latex: \left[ \left| 3+x\right| =10 \right] 
% Soal No. 24
>$& fourier_elim(abs(x-4)+3=9,[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-157.png
% // latex: \left[ x=10 \right] \lor \left[ x=-2 \right] 
% Soal No. 25
>$& fourier_elim(abs(3*x+1)-4=(-1),[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-158.png
% // latex: \left[ x=\frac{2}{3} \right] \lor \left[ x=-\frac{4}{3} \right] 
% Soal No. 32
>$& solve(5-abs(4*x+3)=2)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-159.png
% // latex: \left[ \left| 3+4\,x\right| =3 \right] 
% Soal No. 30
>$& fourier_elim(9-abs(x-2)=7,[x])
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-160.png
% // latex: \left[ x=4 \right] \lor \left[ x=0 \right] 
% ** Latihan Soal 4.3
% 
% Soal No. 70
> 
>$ powerdisp: true
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-161.png
% // latex: \mathbf{true}
> $&( ratsimp((x^4-y^4)/(x-y)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-162.png
% // latex: x^3+x^2\,y+x\,y^2+y^3
% Soal No. 19
>$& ratsimp((x^4-1)/(x-1))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-163.png
% // latex: 1+x+x^2+x^3
% Soal No. 17
>$ powerdisp:true
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-164.png
% // latex: \mathbf{true}
>$& ratsimp((x^5+x^3-x)/(x-3))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-165.png
% // latex: \frac{-x+x^3+x^5}{-3+x}
% Soal No. 22
>$& solve(ratsimp((3*x^2-2*x^2+2)/(x-(1/4))))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-166.png
% // latex: \left[ x=-\sqrt{2}\,i , x=\sqrt{2}\,i \right] 
% Soal No. 11
>$& (ratsimp((2*x^4+7*x^3+x-12)/(x+3)))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-167.png
% // latex: \frac{-12+x+7\,x^3+2\,x^4}{3+x}
% ** Latihan Soal R7
% 
% Soal No. 76
>$& factor(m^(6*n)-m^(3*n))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-168.png
% // latex: m^{3\,n}\,\left(-1+m^{n}\right)\,\left(1+m^{n}+m^{2\,n}\right)
% Soal No. 70
>$& expand(((x^n)+10)*((x^n)-4))
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-169.png
% // latex: -40+6\,x^{n}+x^{2\,n}
% Soal No. 75
>$& factor(x^(2*t)-3*x^t-28)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-170.png
% // latex: \left(-7+x^{t}\right)\,\left(4+x^{t}\right)
% Soal No. 74
>$& factor(y^(2*n)+16*y^n+64)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-171.png
% // latex: \left(8+y^{n}\right)^2
% Soal No. 73
>$& expand((a^n-b^n)^3)
 %image% EMT4Aljabar_Saphira Nuria Salsabila_22305141050-172.png
% // latex: a^{3\,n}-3\,a^{2\,n}\,b^{n}+3\,a^{n}\,b^{2\,n}-b^{3\,n}
>
